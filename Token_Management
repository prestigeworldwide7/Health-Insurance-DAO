fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> ProgramResult {
    let accounts_iter = &mut accounts.iter();
    let account = next_account_info(accounts_iter)?;

    if account.owner != program_id {
        return Err(ProgramError::IncorrectProgramId);
    }

    let mut dao_data = HealthInsuranceDAO::try_from_slice(&account.data.borrow())?;

    match instruction_data[0] {
        // ... existing instructions ...
        3 => {
            // Mint Tokens Instruction
            let mint = next_account_info(accounts_iter)?;
            let to = next_account_info(accounts_iter)?;
            let authority = next_account_info(accounts_iter)?;
            let token_program = next_account_info(accounts_iter)?;

            if !authority.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            let mint_info = Mint::unpack_unchecked(&mint.data.borrow())?;
            let amount = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

            spl_token::instruction::mint_to(
                token_program.key,
                mint.key,
                to.key,
                authority.key,
                &[],
                amount,
            )?;

            if let Some(token_management) = &mut dao_data.token_management {
                token_management.total_supply = token_management.total_supply.checked_add(amount).ok_or(ProgramError::ArithmeticOverflow)?;
            } else {
                return Err(ProgramError::InvalidAccountData); // No token management setup
            }

            msg!("Minted {} tokens to {}", amount, to.key);
        }
        4 => {
            // Transfer Tokens Instruction
            let from = next_account_info(accounts_iter)?;
            let to = next_account_info(accounts_iter)?;
            let authority = next_account_info(accounts_iter)?;
            let token_program = next_account_info(accounts_iter)?;

            if !authority.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            let amount = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

            spl_token::instruction::transfer(
                token_program.key,
                from.key,
                to.key,
                authority.key,
                &[],
                amount,
            )?;

            msg!("Transferred {} tokens from {} to {}", amount, from.key, to.key);
        }
        5 => {
            // Burn Tokens Instruction
            let token_account = next_account_info(accounts_iter)?;
            let mint = next_account_info(accounts_iter)?;
            let authority = next_account_info(accounts_iter)?;
            let token_program = next_account_info(accounts_iter)?;

            if !authority.is_signer {
                return Err(ProgramError::MissingRequiredSignature);
            }

            let amount = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

            spl_token::instruction::burn(
                token_program.key,
                token_account.key,
                mint.key,
                authority.key,
                &[],
                amount,
            )?;

            if let Some(token_management) = &mut dao_data.token_management {
                token_management.total_supply = token_management.total_supply.checked_sub(amount).ok_or(ProgramError::ArithmeticOverflow)?;
            } else {
                return Err(ProgramError::InvalidAccountData); // No token management setup
            }

            msg!("Burned {} tokens", amount);
        }
        _ => return Err(ProgramError::InvalidInstructionData),
    }

    dao_data.serialize(&mut &mut account.data.borrow_mut()[..])?;
    Ok(())
}
